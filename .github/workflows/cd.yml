name: cd

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: cd-preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:

  auto_version_bump:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      bumped: ${{ steps.bump_state.outputs.bumped }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Initialize state
        run: echo "AUTO_BUMPED=false" >> "$GITHUB_ENV"

      - name: Ensure branch is up to date with main
        run: |
          git fetch origin main --depth=1
          if ! git merge-base --is-ancestor origin/main HEAD; then
            echo "::error::This branch is behind main. Please rebase or merge the latest main before pushing."
            exit 1
          fi
          BASE_VERSION=$(git show origin/main:package.json | jq -r .version)
          echo "BASELINE_VERSION=${BASE_VERSION}" >> "$GITHUB_ENV"

      - name: Determine if bump already applied
        id: evaluate
        run: |
          NEEDS=$(node - <<'EOF'
            const fs = require('fs');
            const pkgVersion = JSON.parse(fs.readFileSync('package.json', 'utf8')).version;
            const baseVersion = process.env.BASELINE_VERSION || pkgVersion;
            const parse = (v) => v.split('.').map(Number);
            const cmp = (a, b) => {
              for (let i = 0; i < Math.max(a.length, b.length); i += 1) {
                const left = a[i] ?? 0;
                const right = b[i] ?? 0;
                if (left !== right) return left - right;
              }
              return 0;
            };
            const needs = cmp(parse(pkgVersion), parse(baseVersion)) <= 0 ? 'true' : 'false';
            process.stdout.write(needs);
          EOF
          )
          echo "needs=${NEEDS}" >> "$GITHUB_OUTPUT"

      - name: Bump patch version in package.json
        if: steps.evaluate.outputs.needs == 'true'
        id: bump
        run: |
          NEW_VERSION=$(node - <<'EOF'
            const fs = require('fs');
            const path = 'package.json';
            const pkg = JSON.parse(fs.readFileSync(path, 'utf8'));
            const baseline = process.env.BASELINE_VERSION || pkg.version;
            const parse = (v) => v.split('.').map(Number);
            const cmp = (a, b) => {
              for (let i = 0; i < Math.max(a.length, b.length); i += 1) {
                const left = a[i] ?? 0;
                const right = b[i] ?? 0;
                if (left !== right) return left - right;
              }
              return 0;
            };
            const pkgParts = parse(pkg.version);
            const baseParts = parse(baseline);
            const source = cmp(pkgParts, baseParts) >= 0 ? pkgParts : baseParts;
            source[2] = (source[2] ?? 0) + 1;
            pkg.version = source.join('.');
            fs.writeFileSync(path, JSON.stringify(pkg, null, 2) + '\n');
            process.stdout.write(pkg.version);
          EOF
          )
          echo "Auto-bumped version to ${NEW_VERSION}"
          git status --short package.json
          echo "AUTO_VERSION=${NEW_VERSION}" >> "$GITHUB_ENV"
          NOTES_FILE="docs/release_notes/${NEW_VERSION}.md"
          echo "RELEASE_NOTES_FILE=${NOTES_FILE}" >> "$GITHUB_ENV"
          if [ ! -f "${NOTES_FILE}" ]; then
            mkdir -p "$(dirname "${NOTES_FILE}")"
            {
              echo "# Release notes for ${NEW_VERSION}"
              echo
              echo "- TODO: Describe changes included in this release."
            } > "${NOTES_FILE}"
            echo "Created stub release-notes file at ${NOTES_FILE}"
          else
            echo "Release-notes file already exists at ${NOTES_FILE}, leaving as is."
          fi

      - name: Commit version bump
        if: steps.evaluate.outputs.needs == 'true'
        run: |
          if git diff --quiet -- package.json; then
            echo "::error::Version bump did not modify package.json"
            exit 1
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          if [ -n "${RELEASE_NOTES_FILE:-}" ] && [ -f "${RELEASE_NOTES_FILE}" ]; then
            git add package.json "${RELEASE_NOTES_FILE}"
          else
            git add package.json
          fi
          COMMIT_MSG="chore: auto bump version to ${AUTO_VERSION:-$(jq -r .version package.json)} [auto-bump]"
          git commit -m "${COMMIT_MSG}"

      - name: Push auto bump commit
        if: steps.evaluate.outputs.needs == 'true'
        run: |
          set +e
          git push origin HEAD:${{ github.head_ref }}
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            echo "AUTO_BUMPED=true" >> "$GITHUB_ENV"
            exit 0
          fi
          echo "Push failed, checking for existing auto bump commit..."
          git fetch origin ${{ github.head_ref }}
          git reset --hard origin/${{ github.head_ref }}
          LAST_MSG="$(git log -1 --pretty=%B)"
          if [[ "$LAST_MSG" == *"[auto-bump]"* ]]; then
            echo "AUTO_BUMPED=true" >> "$GITHUB_ENV"
            exit 0
          fi
          echo "::error::Auto version bump push failed. Please resolve manually."
          exit 1

      - name: Emit bump state
        id: bump_state
        run: echo "bumped=${AUTO_BUMPED:-false}" >> "$GITHUB_OUTPUT"

  check_version_number:
    if: github.event.pull_request.state == 'open' && github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Compare package.json versions
        run: |
          # Fetch the main branch package.json
          git fetch origin main
          MAIN_VERSION=$(jq -r .version <(git show origin/main:package.json))
          PR_VERSION=$(jq -r .version < package.json)
          echo "Main branch version: $MAIN_VERSION"
          echo "PR branch version: $PR_VERSION"
          # Compare versions
          if [ "$(printf '%s\n%s' "$MAIN_VERSION" "$PR_VERSION" | sort -V | head -n1)" != "$MAIN_VERSION" ] || [ "$MAIN_VERSION" == "$PR_VERSION" ]; then
            echo "Error: PR version ($PR_VERSION) must be strictly greater than main version ($MAIN_VERSION)."
            exit 1
          fi

  release_notes_check:
    needs: auto_version_bump
    if: github.event.pull_request.state == 'open' && github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    outputs:
      release_notes: ${{ steps.check.outputs.release_notes }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Check release notes
        id: check
        uses: ./.github/actions/release_notes_check
        with:
          version_file: 'package.json'
          notes_dir: 'docs/release_notes'
          notes_ext: '.md'

  deploy_android:
    if: github.event.pull_request.state == 'open' && github.event.pull_request.draft == false
    needs: [check_version_number, release_notes_check]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (root for actions)
        uses: actions/checkout@v3

      - name: Checkout (app code)
        uses: actions/checkout@v3
        with:
          path: app

      - name: Deploy android app to Firebase App Distribution
        uses: ./.github/actions/deploy_android_preview
        with:
          ANDROID_GCP_JSON_BASE64: ${{ secrets.ANDROID_GCP_JSON_BASE64 }}
          ANDROID_FIREBASE_PROJECT_NUMBER: ${{ secrets.ANDROID_FIREBASE_PROJECT_NUMBER }}
          ANDROID_FIREBASE_APP_ID: ${{ secrets.ANDROID_FIREBASE_APP_ID }}
          ANDROID_FIREBASE_PROJECT_ID: ${{ secrets.ANDROID_FIREBASE_PROJECT_ID }}
          ANDROID_FIREBASE_APP_PACKAGE: ${{ secrets.ANDROID_FIREBASE_APP_PACKAGE }}
          ANDROID_FIREBASE_API_KEY: ${{ secrets.ANDROID_FIREBASE_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          RELEASE_NOTES: ${{ needs.release_notes_check.outputs.release_notes }}
  # deploy_ios:
  #   if: github.event.pull_request.state == 'open' && github.event.pull_request.draft == false
  #   needs: [build, release_notes_check]
  #   runs-on: macos-14
  #   timeout-minutes: 30
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v3

  #     - name: Deploy iOS Preview to TestFlight
  #       uses: ./.github/actions/deploy_ios_preview
  #       env:
  #         MATCH_PASSWORD: ${{ secrets.IOS_MATCH_PASSWORD }}
  #         IOS_MATCH_REPOSITORY_URL: ${{ secrets.IOS_MATCH_REPOSITORY_URL }}
  #         IOS_APPLE_ID: ${{ secrets.IOS_APPLE_ID }}
  #         IOS_KEYCHAIN_PASSWORD: ${{ secrets.IOS_KEYCHAIN_PASSWORD }}
  #         IOS_APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.IOS_APP_STORE_CONNECT_API_KEY_ID }}
  #         IOS_APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.IOS_APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
  #         IOS_APP_STORE_CONNECT_API_KEY_B64: ${{ secrets.IOS_APP_STORE_CONNECT_API_KEY_B64 }}
  #         IOS_APP_IDENTIFIER: ${{ secrets.IOS_APP_IDENTIFIER }}
  #         IOS_APP_STORE_TEAM_ID: ${{ secrets.IOS_APP_STORE_TEAM_ID }}
  #         IOS_DEV_EMAIL: ${{ secrets.IOS_DEV_EMAIL }}
  #         IOS_MATCH_DEPLOY_KEY: ${{ secrets.IOS_MATCH_DEPLOY_KEY }}
  #         PR_NUMBER: ${{ github.event.pull_request.number }}
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         RELEASE_NOTES: ${{ needs.release-notes-check.outputs.release_notes }}
