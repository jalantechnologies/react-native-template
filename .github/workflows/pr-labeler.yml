name: pr-labeler

on:
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: Label PR based on title prefix
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const title = context.payload.pull_request.title;
            const prNumber = context.payload.pull_request.number;

            // Define label mappings based on PR title prefix (with optional scope)
            const labelMappings = [
              { pattern: /^feat(\(.+?\))?!:/i, typeLabel: 'type: feat', semverLabel: 'semver: major' },
              { pattern: /^fix(\(.+?\))?!:/i, typeLabel: 'type: fix', semverLabel: 'semver: major' },
              { pattern: /^feat(\(.+?\))?:/i, typeLabel: 'type: feat', semverLabel: 'semver: minor' },
              { pattern: /^fix(\(.+?\))?:/i, typeLabel: 'type: fix', semverLabel: 'semver: patch' },
              { pattern: /^perf(\(.+?\))?:/i, typeLabel: 'type: perf', semverLabel: 'semver: patch' },
              { pattern: /^docs(\(.+?\))?:/i, typeLabel: 'type: docs', semverLabel: null },
              { pattern: /^style(\(.+?\))?:/i, typeLabel: 'type: style', semverLabel: null },
              { pattern: /^refactor(\(.+?\))?:/i, typeLabel: 'type: refactor', semverLabel: null },
              { pattern: /^test(\(.+?\))?:/i, typeLabel: 'type: test', semverLabel: null },
              { pattern: /^chore(\(.+?\))?:/i, typeLabel: 'type: chore', semverLabel: null },
              { pattern: /^ci(\(.+?\))?:/i, typeLabel: 'type: ci', semverLabel: null },
            ];

            // Label metadata (color + description) for auto-created labels
            const labelDetails = {
              'type: feat': { color: '2E8B57', description: 'User-facing feature or enhancement' },
              'type: fix': { color: 'D73A4A', description: 'User-visible bug fix' },
              'type: perf': { color: 'BFDADC', description: 'Performance improvements' },
              'type: docs': { color: '0366D6', description: 'Documentation-only change' },
              'type: style': { color: 'F9D0C4', description: 'Formatting or stylistic tweaks (no logic change)' },
              'type: refactor': { color: '8A63D2', description: 'Code restructuring without behavior change' },
              'type: test': { color: '0E8A16', description: 'Add or update tests' },
              'type: chore': { color: 'BFD4F2', description: 'Maintenance or tooling upkeep' },
              'type: ci': { color: 'F9BC2F', description: 'CI/CD configuration or pipeline updates' },
              'semver: major': { color: 'B60205', description: 'Breaking change; requires major bump' },
              'semver: minor': { color: '5319E7', description: 'Backward-compatible feature' },
              'semver: patch': { color: '1D76DB', description: 'Backward-compatible bug or perf fix' },
            };

            const ensureLabel = async (name) => {
              const meta = labelDetails[name];
              if (!meta) return;
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name,
                  color: meta.color.replace('#', ''),
                  description: meta.description,
                });
                console.log(`Created label: ${name}`);
              } catch (error) {
                if (error.status === 422) {
                  await github.rest.issues.updateLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name,
                    new_name: name,
                    color: meta.color.replace('#', ''),
                    description: meta.description,
                  });
                  console.log(`Updated label: ${name}`);
                } else {
                  throw error;
                }
              }
            };

            // Ensure type + semver labels exist with colors/descriptions
            const labelsToEnsure = [
              'type: feat',
              'type: fix',
              'type: perf',
              'type: docs',
              'type: style',
              'type: refactor',
              'type: test',
              'type: chore',
              'type: ci',
              'semver: major',
              'semver: minor',
              'semver: patch',
            ];
            await Promise.all(labelsToEnsure.map(ensureLabel));

            // Find matching prefix
            const match = labelMappings.find(mapping => mapping.pattern.test(title));

            if (!match) {
              core.setFailed(`âŒ PR title does not follow conventional commit format. Expected format: type(scope): description\nValid types: feat, fix, perf, docs, style, refactor, test, chore, ci\nExample: feat(api): add new endpoint`);
              return;
            }

            const labelsToAdd = [match.typeLabel];
            if (match.semverLabel) {
              labelsToAdd.push(match.semverLabel);
            }

            // Get existing labels on the PR
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const existingLabelNames = existingLabels.map(label => label.name);

            // Remove old type and semver labels if they differ
            const typeLabels = ['type: feat', 'type: fix', 'type: perf', 'type: docs', 'type: style', 'type: refactor', 'type: test', 'type: chore', 'type: ci'];
            const semverLabels = ['semver: major', 'semver: minor', 'semver: patch'];

            for (const label of existingLabelNames) {
              if ((typeLabels.includes(label) && label !== match.typeLabel) ||
                  (semverLabels.includes(label) && label !== match.semverLabel)) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label,
                });
                console.log(`Removed label: ${label}`);
              }
            }

            // Add new labels
            const labelsToApply = labelsToAdd.filter(label => !existingLabelNames.includes(label));
            if (labelsToApply.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: labelsToApply,
              });
              console.log(`Added labels: ${labelsToApply.join(', ')}`);
            }

            console.log(`PR #${prNumber} labeled with: ${labelsToAdd.join(', ')}`);
