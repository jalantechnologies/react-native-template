name: Release Notes Check
description: Checks if release notes file exists for the current version and outputs the content.

inputs:
  version_file:
    description: 'Path to the version file (default: package.json)'
    required: false
    default: 'package.json'
  notes_dir:
    description: 'Directory containing release notes (default: docs/release_notes)'
    required: false
    default: 'docs/release_notes'
  notes_ext:
    description: 'Release notes file extension (default: .md)'
    required: false
    default: '.md'

outputs:
  release_notes:
    description: 'Content of the release notes file'
    value: ${{ steps.check_notes.outputs.release_notes }}

runs:
  using: "composite"
  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Extract version from JSON
      id: get_version
      shell: bash
      run: |
        VERSION=$(jq -r .version < "${{ inputs.version_file }}")
        echo "Extracted version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Check for release notes file
      id: check_notes
      shell: bash
      run: |
        NOTES_FILE="${{ inputs.notes_dir }}/${{ steps.get_version.outputs.version }}${{ inputs.notes_ext }}"
        echo "Checking release notes file: $NOTES_FILE"
        
        if [ ! -f "$NOTES_FILE" ]; then
          echo "::error::‚ùå Release notes file not found: $NOTES_FILE"
          exit 1
        fi
        
        echo "‚úÖ Release notes file found: $NOTES_FILE"

        CONTENT=$(cat "$NOTES_FILE")
        {
          echo 'release_notes<<EOF'
          echo "$CONTENT"
          echo 'EOF'
        } >> $GITHUB_OUTPUT
        
    - name: Write release notes to fastlane metadata (default + version-specific)
      id: write_changelogs
      shell: bash
      run: |
        set -euo pipefail

        # release text from check step
        RELEASE_NOTES="${{ steps.check_notes.outputs.release_notes }}"

        if [ -z "$RELEASE_NOTES" ]; then
          echo "‚ö†Ô∏è No release notes content to write"
          exit 0
        fi

        # compute versionName from package.json (repo root)
        VERSION_JSON_PATH="${{ inputs.version_file }}"   # usually package.json
        version_name=$(jq -r .version < "$VERSION_JSON_PATH")
        echo "üîñ versionName from $VERSION_JSON_PATH -> $version_name"

        # compute numeric versionCode using your formula (major*10000 + minor*100 + patch)
        IFS='.' read -r major minor patch <<< "$version_name"
        major=${major:-0}; minor=${minor:-0}; patch=${patch:-0}
        version_code=$(( major * 10000 + minor * 100 + patch ))
        echo "üî¢ computed versionCode -> $version_code"

        # canonical fastlane metadata dir relative to where fastlane runs (common case: android/)
        CANONICAL="fastlane/metadata/android/en-US/changelogs"
        # also write to android/fastlane for safety in case actions run from repo root
        ALT="android/fastlane/metadata/android/en-US/changelogs"

        for DIR in "$CANONICAL" "$ALT"; do
          mkdir -p "$DIR"
          echo "üìÑ Writing default.txt -> $DIR/default.txt"
          printf "%s\n" "$RELEASE_NOTES" > "$DIR/default.txt"
          echo "üìÑ Writing ${version_code}.txt -> $DIR/${version_code}.txt"
          printf "%s\n" "$RELEASE_NOTES" > "$DIR/${version_code}.txt"
        done

        echo "‚úÖ Changelog files created:"
        echo " - $CANONICAL/default.txt"
        echo " - $CANONICAL/${version_code}.txt"
        echo " - $ALT/default.txt"
        echo " - $ALT/${version_code}.txt"

        # expose computed version (optional)
        echo "version_code=$version_code" >> $GITHUB_OUTPUT
        echo "version_name=$version_name" >> $GITHUB_OUTPUT

