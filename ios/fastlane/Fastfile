default_platform(:ios)

platform :ios do
  desc "Setup code signing"
  lane :ci_signing_setup do
    match(
      type: "appstore",
      readonly: true,
      keychain_name: "ios.keychain",
      keychain_password: ENV["IOS_KEYCHAIN_PASSWORD"]
    )
  end

  desc "Build IPA for App Store"
  lane :build_ipa do
    build_app(
      clean: true,
      scheme: ENV["IOS_SCHEME"] || "YourApp", # replace or set in secrets
      export_method: "app-store",
      output_directory: "./", # ensures ipa is in ios/
      output_name: "#{ENV['IOS_SCHEME'] || 'YourApp'}.ipa",
      xcargs: "CODE_SIGN_STYLE=Manual " \
              "CODE_SIGN_IDENTITY=\"Apple Distribution\" " \
              "DEVELOPMENT_TEAM=#{ENV['IOS_TEAM_ID']} " \
              "PROVISIONING_PROFILE_SPECIFIER=\"match AppStore #{ENV['IOS_APP_IDENTIFIER']}\" " \
              "PRODUCT_BUNDLE_IDENTIFIER=#{ENV['IOS_APP_IDENTIFIER']}",
      export_options: {
        compileBitcode: false,
        signingStyle: "manual",
        provisioningProfiles: {
          ENV['IOS_APP_IDENTIFIER'] => "match AppStore #{ENV['IOS_APP_IDENTIFIER']}"
        }
      }
    )
  end

  desc "Upload existing IPA to TestFlight"
  lane :upload_existing_ipa do
    ipa_path = ENV["IPA_OUTPUT_PATH"] || Dir["./*.ipa"].first
    unless ipa_path
      UI.user_error!("No IPA found in #{Dir.pwd}")
    end

    api_key = {
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_B64"],
      is_key_content_base64: true
    }

    upload_to_testflight(
      api_key: api_key,
      ipa: ipa_path,
      skip_submission: true,
      skip_waiting_for_build_processing: false
    )
  end

  desc "Build and upload in one go"
  lane :ci_build_and_upload do
    build_ipa
    ENV["IPA_OUTPUT_PATH"] = Dir["./*.ipa"].first # Pass the path to upload step
    upload_existing_ipa
  end
end
